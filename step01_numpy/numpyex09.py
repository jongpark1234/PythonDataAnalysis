import numpy as np

# 행의 수나 열의 수가 같은 배열에 대해서 연결

# hstack : 옆으로 붙여 나가는 방식 ( 행의 개수 일치가 필수 )
a1 = np.zeros((2, 3)) # [[0, 0, 0], [0, 0, 0]]

a2 = np.ones((2, 2)) # [[1, 1], [1, 1]]

hs = np.hstack([a1, a2]) # [[0, 0, 0, 1, 1], [0, 0, 0, 1, 1]]

print(hs)

# vstack : 아래로 붙여 나가는 방식 ( 열의 개수 일치가 필수 )

b1 = np.zeros((2, 3)) # [[0, 0, 0], [0, 0, 0]]

b2 = np.ones((3, 3)) # [[1, 1, 1], [1, 1, 1], [1, 1, 1]]

vs = np.vstack([b1, b2]) # [[0, 0, 0], [0, 0, 0], [1, 1, 1], [1, 1, 1], [1, 1, 1]]

print(vs)

# dstack : 제 3의 축 방향으로 배열을 결합하는 방식

c1 = np.zeros((3, 4)) # [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]

c2 = np.ones((3, 4)) # [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]

ds = np.dstack([c1, c2]) # [[[0, 1], [0, 1], [0, 1], [0, 1]], [[0, 1], [0, 1], [0, 1], [0, 1]], [[0, 1], [0, 1], [0, 1], [0, 1]]]

print(ds)

# stack : 사용자가 지정한 방향으로 배열을 연결
# axis 인수를 사용하여 연결 후의 회전 방향을 설정

s1 = np.stack([c1, c2]) # [[[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]], [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]]

print(s1)

s2 = np.stack([c1, c2], axis = 1) # [[[0, 0, 0, 0], [1, 1, 1, 1]], [[0, 0, 0, 0], [1, 1, 1, 1]], [[0, 0, 0, 0], [1, 1, 1, 1]]]

print(s2)

# indexeer : () 대신 [] 를 사용한다. 특수 메소드
# 배열을 연결함

ruh = np.r_[np.array([1, 2, 3]), np.array([4, 5, 6])]

print(ruh) # [1 2 3 4 5 6]

# c_ : 배열의 차원을 증가 시킨 뒤 연결
# 1차원 배열을 연결하면 2차원 배열이 됨

cuh = np.c_[np.array([1, 2, 3]), np.array([4, 5, 6])]

print(cuh) # [[1, 4], [2, 5], [3, 6]]

# tile : 동일한 배열을 반복해서 연결

ti = np.array([[1, 2, 3], [4, 5, 6]]) # [[1 2 3 1 2 3 1 2 3 1 2 3 1 2 3], [4 5 6 4 5 6 4 5 6 4 5 6 4 5 6]]

print(np.tile(ti, 5))

print(np.tile(ti, (3, 2))) # [[1 2 3 1 2 3], [4 5 6 4 5 6], [1 2 3 1 2 3], [4 5 6 4 5 6], [1 2 3 1 2 3], [4 5 6 4 5 6]]


# 문제. 다음과 같은 배열을 만들어 보자.

# array([0, 0, 0, 1, 1],
#       [0, 0, 0, 1, 1], 
#       [0, 0, 0, 1, 1], 
#       [10, 20, 30, 40, 50], 
#       [60, 70, 80, 90, 100], 
#       [110, 120, 130, 140, 150])

print(np.vstack([np.tile(np.hstack([np.zeros(3), np.ones(2)]), (3, 1)), np.arange(10, 160, 10).reshape(3, -1)]))
